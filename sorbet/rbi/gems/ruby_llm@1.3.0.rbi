# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby_llm` gem.
# Please instead update this file by running `bin/tapioca gem ruby_llm`.


# A delightful Ruby interface to modern AI language models.
# Provides a unified way to interact with models from OpenAI, Anthropic and others
# with a focus on developer happiness and convention over configuration.
#
# source://ruby_llm//lib/ruby_llm.rb#31
module RubyLLM
  class << self
    # source://ruby_llm//lib/ruby_llm.rb#41
    def chat(*_arg0, **_arg1, &_arg2); end

    # source://ruby_llm//lib/ruby_llm.rb#65
    def config; end

    # @yield [config]
    #
    # source://ruby_llm//lib/ruby_llm.rb#61
    def configure; end

    # @yield [context_config]
    #
    # source://ruby_llm//lib/ruby_llm.rb#35
    def context; end

    # source://ruby_llm//lib/ruby_llm.rb#45
    def embed(*_arg0, **_arg1, &_arg2); end

    # source://ruby_llm//lib/ruby_llm.rb#69
    def logger; end

    # source://ruby_llm//lib/ruby_llm.rb#53
    def models; end

    # source://ruby_llm//lib/ruby_llm.rb#49
    def paint(*_arg0, **_arg1, &_arg2); end

    # source://ruby_llm//lib/ruby_llm.rb#57
    def providers; end
  end
end

# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#4
module RubyLLM::ActiveRecord; end

# Adds chat and message persistence capabilities to ActiveRecord models.
# Provides a clean interface for storing chat history, message metadata,
# and attachments in your database.
#
# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#8
module RubyLLM::ActiveRecord::ActsAs
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RubyLLM::ActiveRecord::ActsAs::ClassMethods
end

# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#0
module RubyLLM::ActiveRecord::ActsAs::ClassMethods
  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#12
  def acts_as_chat(message_class: T.unsafe(nil), tool_call_class: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#26
  def acts_as_message(chat_class: T.unsafe(nil), chat_foreign_key: T.unsafe(nil), tool_call_class: T.unsafe(nil), tool_call_foreign_key: T.unsafe(nil), touch_chat: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#58
  def acts_as_tool_call(message_class: T.unsafe(nil), message_foreign_key: T.unsafe(nil), result_foreign_key: T.unsafe(nil)); end
end

# Methods mixed into chat models to handle message persistence and
# provide a conversation interface.
#
# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#79
module RubyLLM::ActiveRecord::ChatMethods
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RubyLLM::ActiveRecord::ChatMethods::ClassMethods

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#148
  def ask(message, with: T.unsafe(nil), &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#155
  def complete(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#142
  def create_user_message(content, with: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#137
  def on_end_message(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#132
  def on_new_message(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#148
  def say(message, with: T.unsafe(nil), &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#86
  def to_llm; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#127
  def with_context(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#98
  def with_instructions(instructions, replace: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#117
  def with_model(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#122
  def with_temperature(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#107
  def with_tool(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#112
  def with_tools(*_arg0, **_arg1, &_arg2); end

  private

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#224
  def convert_to_active_storage_format(source); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#198
  def find_tool_call_id(tool_call_id); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#202
  def persist_content(message_record, attachments); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#171
  def persist_message_completion(message); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#167
  def persist_new_message; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#190
  def persist_tool_calls(tool_calls); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#209
  def prepare_for_active_storage(attachments); end
end

# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#0
module RubyLLM::ActiveRecord::ChatMethods::ClassMethods
  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#83
  def tool_call_class; end
end

# Methods mixed into message models to handle serialization and
# provide a clean interface to the underlying message data.
#
# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#243
module RubyLLM::ActiveRecord::MessageMethods
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::RubyLLM::ActiveRecord::MessageMethods::ClassMethods

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#250
  def to_llm; end

  private

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#294
  def download_attachment(attachment); end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#281
  def extract_content; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#277
  def extract_tool_call_id; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#264
  def extract_tool_calls; end
end

# source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#0
module RubyLLM::ActiveRecord::MessageMethods::ClassMethods
  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#247
  def chat_class; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#247
  def chat_foreign_key; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#247
  def tool_call_class; end

  # source://ruby_llm//lib/ruby_llm/active_record/acts_as.rb#247
  def tool_call_foreign_key; end
end

# Manages model aliases, allowing users to reference models by simpler names
# that map to specific model versions across different providers.
#
# Aliases are defined in aliases.json and follow the format:
#   {
#     "simple-name": {
#       "provider1": "specific-version-for-provider1",
#       "provider2": "specific-version-for-provider2"
#     }
#   }
#
# source://ruby_llm//lib/ruby_llm/aliases.rb#14
class RubyLLM::Aliases
  class << self
    # Returns the loaded aliases mapping
    #
    # @return [Hash] the aliases mapping
    #
    # source://ruby_llm//lib/ruby_llm/aliases.rb#34
    def aliases; end

    # Loads aliases from the JSON file
    #
    # @return [Hash] the loaded aliases
    #
    # source://ruby_llm//lib/ruby_llm/aliases.rb#40
    def load_aliases; end

    # Reloads aliases from disk
    #
    # @return [Hash] the reloaded aliases
    #
    # source://ruby_llm//lib/ruby_llm/aliases.rb#51
    def reload!; end

    # Resolves a model ID to its provider-specific version
    #
    # @param model_id [String] the model identifier or alias
    # @param provider_slug [String, Symbol, nil] optional provider to resolve for
    # @return [String] the resolved model ID or the original if no alias exists
    #
    # source://ruby_llm//lib/ruby_llm/aliases.rb#21
    def resolve(model_id, provider = T.unsafe(nil)); end
  end
end

# A class representing a file attachment.
#
# source://ruby_llm//lib/ruby_llm/attachment.rb#5
class RubyLLM::Attachment
  # @return [Attachment] a new instance of Attachment
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#8
  def initialize(source, filename: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#37
  def active_storage?; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#81
  def audio?; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#45
  def content; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#64
  def encoded; end

  # Returns the value of attribute filename.
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#6
  def filename; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#77
  def image?; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#33
  def io_like?; end

  # Returns the value of attribute mime_type.
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#6
  def mime_type; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#29
  def path?; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#85
  def pdf?; end

  # Returns the value of attribute source.
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#6
  def source; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#89
  def text?; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#93
  def to_h; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#68
  def type; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/attachment.rb#25
  def url?; end

  private

  # source://ruby_llm//lib/ruby_llm/attachment.rb#151
  def active_storage_content_type; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#99
  def determine_mime_type; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#136
  def extract_filename_from_active_storage; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#107
  def fetch_content; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#121
  def load_content_from_active_storage; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#116
  def load_content_from_io; end

  # source://ruby_llm//lib/ruby_llm/attachment.rb#112
  def load_content_from_path; end
end

# Error classes for different HTTP status codes
#
# source://ruby_llm//lib/ruby_llm/error.rb#30
class RubyLLM::BadRequestError < ::RubyLLM::Error; end

# Represents a conversation with an AI model. Handles message history,
# streaming responses, and tool integration with a simple, conversational API.
#
# Example:
#   chat = RubyLLM.chat
#   chat.ask "What's the best way to learn Ruby?"
#   chat.ask "Can you elaborate on that?"
#
# source://ruby_llm//lib/ruby_llm/chat.rb#11
class RubyLLM::Chat
  include ::Enumerable

  # @return [Chat] a new instance of Chat
  #
  # source://ruby_llm//lib/ruby_llm/chat.rb#16
  def initialize(model: T.unsafe(nil), provider: T.unsafe(nil), assume_model_exists: T.unsafe(nil), context: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#115
  def add_message(message_or_attributes); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#34
  def ask(message = T.unsafe(nil), with: T.unsafe(nil), &_arg2); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#95
  def complete(&_arg0); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#91
  def each(&_arg0); end

  # Returns the value of attribute messages.
  #
  # source://ruby_llm//lib/ruby_llm/chat.rb#14
  def messages; end

  # Returns the value of attribute model.
  #
  # source://ruby_llm//lib/ruby_llm/chat.rb#14
  def model; end

  # source://ruby_llm//lib/ruby_llm/chat.rb#86
  def on_end_message(&block); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#81
  def on_new_message(&block); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#121
  def reset_messages!; end

  # source://ruby_llm//lib/ruby_llm/chat.rb#34
  def say(message = T.unsafe(nil), with: T.unsafe(nil), &_arg2); end

  # Returns the value of attribute tools.
  #
  # source://ruby_llm//lib/ruby_llm/chat.rb#14
  def tools; end

  # source://ruby_llm//lib/ruby_llm/chat.rb#74
  def with_context(context); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#41
  def with_instructions(instructions, replace: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#63
  def with_model(model_id, provider: T.unsafe(nil), assume_exists: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#69
  def with_temperature(temperature); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#48
  def with_tool(tool); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#58
  def with_tools(*tools); end

  private

  # source://ruby_llm//lib/ruby_llm/chat.rb#144
  def add_tool_result(tool_use_id, result); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#138
  def execute_tool(tool_call); end

  # source://ruby_llm//lib/ruby_llm/chat.rb#127
  def handle_tool_calls(response, &_arg1); end
end

# source://ruby_llm//lib/ruby_llm/chunk.rb#4
class RubyLLM::Chunk < ::RubyLLM::Message; end

# Global configuration for RubyLLM. Manages API keys, default models,
# and provider-specific settings.
#
# Configure via:
#   RubyLLM.configure do |config|
#     config.openai_api_key = ENV['OPENAI_API_KEY']
#     config.anthropic_api_key = ENV['ANTHROPIC_API_KEY']
#   end
#
# source://ruby_llm//lib/ruby_llm/configuration.rb#12
class RubyLLM::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#43
  def initialize; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def anthropic_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def anthropic_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_region; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_region=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_secret_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_secret_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_session_token; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def bedrock_session_token=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def deepseek_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def deepseek_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_embedding_model; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_embedding_model=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_image_model; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_image_model=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_model; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def default_model=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def gemini_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def gemini_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def http_proxy; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def http_proxy=(_arg0); end

  # source://ruby_llm//lib/ruby_llm/configuration.rb#63
  def inspect; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_assume_model_exists; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_assume_model_exists=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_file; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_file=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_level; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def log_level=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def max_retries; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def max_retries=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def ollama_api_base; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def ollama_api_base=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_api_base; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_api_base=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_organization_id; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_organization_id=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_project_id; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openai_project_id=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openrouter_api_key; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def openrouter_api_key=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def request_timeout; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def request_timeout=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_backoff_factor; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_backoff_factor=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_interval; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_interval=(_arg0); end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_interval_randomness; end

  # Provider-specific configuration
  #
  # source://ruby_llm//lib/ruby_llm/configuration.rb#14
  def retry_interval_randomness=(_arg0); end
end

# Error classes for non-HTTP errors
#
# source://ruby_llm//lib/ruby_llm/error.rb#23
class RubyLLM::ConfigurationError < ::StandardError; end

# Connection class for managing API connections to various providers.
#
# source://ruby_llm//lib/ruby_llm/connection.rb#5
class RubyLLM::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://ruby_llm//lib/ruby_llm/connection.rb#22
  def initialize(provider, config); end

  # Returns the value of attribute config.
  #
  # source://ruby_llm//lib/ruby_llm/connection.rb#6
  def config; end

  # Returns the value of attribute connection.
  #
  # source://ruby_llm//lib/ruby_llm/connection.rb#6
  def connection; end

  # source://ruby_llm//lib/ruby_llm/connection.rb#44
  def get(url, &_arg1); end

  # source://ruby_llm//lib/ruby_llm/connection.rb#36
  def post(url, payload, &_arg2); end

  # Returns the value of attribute provider.
  #
  # source://ruby_llm//lib/ruby_llm/connection.rb#6
  def provider; end

  private

  # @raise [ConfigurationError]
  #
  # source://ruby_llm//lib/ruby_llm/connection.rb#108
  def ensure_configured!; end

  # source://ruby_llm//lib/ruby_llm/connection.rb#94
  def retry_exceptions; end

  # source://ruby_llm//lib/ruby_llm/connection.rb#88
  def setup_http_proxy(faraday); end

  # source://ruby_llm//lib/ruby_llm/connection.rb#57
  def setup_logging(faraday); end

  # source://ruby_llm//lib/ruby_llm/connection.rb#81
  def setup_middleware(faraday); end

  # source://ruby_llm//lib/ruby_llm/connection.rb#70
  def setup_retry(faraday); end

  # source://ruby_llm//lib/ruby_llm/connection.rb#53
  def setup_timeout(faraday); end

  class << self
    # source://ruby_llm//lib/ruby_llm/connection.rb#8
    def basic(&_arg0); end
  end
end

# Represents the content sent to or received from an LLM.
# Selects the appropriate attachment class based on the content type.
#
# source://ruby_llm//lib/ruby_llm/content.rb#6
class RubyLLM::Content
  # @raise [ArgumentError]
  # @return [Content] a new instance of Content
  #
  # source://ruby_llm//lib/ruby_llm/content.rb#9
  def initialize(text = T.unsafe(nil), attachments = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/content.rb#17
  def add_attachment(source, filename: T.unsafe(nil)); end

  # Returns the value of attribute attachments.
  #
  # source://ruby_llm//lib/ruby_llm/content.rb#7
  def attachments; end

  # source://ruby_llm//lib/ruby_llm/content.rb#22
  def format; end

  # Returns the value of attribute text.
  #
  # source://ruby_llm//lib/ruby_llm/content.rb#7
  def text; end

  # For Rails serialization
  #
  # source://ruby_llm//lib/ruby_llm/content.rb#31
  def to_h; end

  private

  # source://ruby_llm//lib/ruby_llm/content.rb#43
  def process_attachments(attachments); end

  # source://ruby_llm//lib/ruby_llm/content.rb#37
  def process_attachments_array_or_string(attachments); end
end

# Holds per-call configs
#
# source://ruby_llm//lib/ruby_llm/context.rb#5
class RubyLLM::Context
  # @return [Context] a new instance of Context
  #
  # source://ruby_llm//lib/ruby_llm/context.rb#8
  def initialize(config); end

  # source://ruby_llm//lib/ruby_llm/context.rb#13
  def chat(*args, **kwargs, &_arg2); end

  # Returns the value of attribute config.
  #
  # source://ruby_llm//lib/ruby_llm/context.rb#6
  def config; end

  # source://ruby_llm//lib/ruby_llm/context.rb#25
  def connection_for(provider_module); end

  # source://ruby_llm//lib/ruby_llm/context.rb#17
  def embed(*args, **kwargs, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/context.rb#21
  def paint(*args, **kwargs, &_arg2); end
end

# Core embedding interface. Provides a clean way to generate embeddings
# from text using various provider models.
#
# source://ruby_llm//lib/ruby_llm/embedding.rb#6
class RubyLLM::Embedding
  # @return [Embedding] a new instance of Embedding
  #
  # source://ruby_llm//lib/ruby_llm/embedding.rb#9
  def initialize(vectors:, model:, input_tokens: T.unsafe(nil)); end

  # Returns the value of attribute input_tokens.
  #
  # source://ruby_llm//lib/ruby_llm/embedding.rb#7
  def input_tokens; end

  # Returns the value of attribute model.
  #
  # source://ruby_llm//lib/ruby_llm/embedding.rb#7
  def model; end

  # Returns the value of attribute vectors.
  #
  # source://ruby_llm//lib/ruby_llm/embedding.rb#7
  def vectors; end

  class << self
    # source://ruby_llm//lib/ruby_llm/embedding.rb#15
    def embed(text, model: T.unsafe(nil), provider: T.unsafe(nil), assume_model_exists: T.unsafe(nil), context: T.unsafe(nil), dimensions: T.unsafe(nil)); end
  end
end

# Custom error class that wraps API errors from different providers
# into a consistent format with helpful error messages.
#
# Example:
#   begin
#     chat.ask "What's 2+2?"
#   rescue RubyLLM::Error => e
#     puts "Couldn't chat with AI: #{e.message}"
#   end
#
# source://ruby_llm//lib/ruby_llm/error.rb#13
class RubyLLM::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://ruby_llm//lib/ruby_llm/error.rb#16
  def initialize(response = T.unsafe(nil), message = T.unsafe(nil)); end

  # Returns the value of attribute response.
  #
  # source://ruby_llm//lib/ruby_llm/error.rb#14
  def response; end
end

# Faraday middleware that maps provider-specific API errors to RubyLLM errors.
# Uses provider's parse_error method to extract meaningful error messages.
#
# source://ruby_llm//lib/ruby_llm/error.rb#41
class RubyLLM::ErrorMiddleware < ::Faraday::Middleware
  # @return [ErrorMiddleware] a new instance of ErrorMiddleware
  #
  # source://ruby_llm//lib/ruby_llm/error.rb#42
  def initialize(app, provider:); end

  # source://ruby_llm//lib/ruby_llm/error.rb#47
  def call(env); end

  class << self
    # source://ruby_llm//lib/ruby_llm/error.rb#54
    def parse_error(provider:, response:); end
  end
end

# source://ruby_llm//lib/ruby_llm/error.rb#31
class RubyLLM::ForbiddenError < ::RubyLLM::Error; end

# Represents a generated image from an AI model.
# Provides an interface to image generation capabilities
# from providers like DALL-E and Gemini's Imagen.
#
# source://ruby_llm//lib/ruby_llm/image.rb#7
class RubyLLM::Image
  # @return [Image] a new instance of Image
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#10
  def initialize(url: T.unsafe(nil), data: T.unsafe(nil), mime_type: T.unsafe(nil), revised_prompt: T.unsafe(nil), model_id: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#18
  def base64?; end

  # Returns the value of attribute data.
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#8
  def data; end

  # Returns the value of attribute mime_type.
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#8
  def mime_type; end

  # Returns the value of attribute model_id.
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#8
  def model_id; end

  # Returns the value of attribute revised_prompt.
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#8
  def revised_prompt; end

  # Saves the image to a file path
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#33
  def save(path); end

  # Returns the raw binary image data regardless of source
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#23
  def to_blob; end

  # Returns the value of attribute url.
  #
  # source://ruby_llm//lib/ruby_llm/image.rb#8
  def url; end

  class << self
    # source://ruby_llm//lib/ruby_llm/image.rb#38
    def paint(prompt, model: T.unsafe(nil), provider: T.unsafe(nil), assume_model_exists: T.unsafe(nil), size: T.unsafe(nil), context: T.unsafe(nil)); end
  end
end

# source://ruby_llm//lib/ruby_llm/error.rb#24
class RubyLLM::InvalidRoleError < ::StandardError; end

# A single message in a chat conversation. Can represent user input,
# AI responses, or tool interactions. Tracks token usage and handles
# the complexities of tool calls and responses.
#
# source://ruby_llm//lib/ruby_llm/message.rb#7
class RubyLLM::Message
  # @return [Message] a new instance of Message
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#12
  def initialize(options = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/message.rb#24
  def content; end

  # Returns the value of attribute input_tokens.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def input_tokens; end

  # Returns the value of attribute model_id.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def model_id; end

  # Returns the value of attribute output_tokens.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def output_tokens; end

  # Returns the value of attribute role.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def role; end

  # source://ruby_llm//lib/ruby_llm/message.rb#44
  def to_h; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#32
  def tool_call?; end

  # Returns the value of attribute tool_call_id.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def tool_call_id; end

  # Returns the value of attribute tool_calls.
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#10
  def tool_calls; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#36
  def tool_result?; end

  # source://ruby_llm//lib/ruby_llm/message.rb#40
  def tool_results; end

  private

  # @raise [InvalidRoleError]
  #
  # source://ruby_llm//lib/ruby_llm/message.rb#66
  def ensure_valid_role; end

  # source://ruby_llm//lib/ruby_llm/message.rb#58
  def normalize_content(content); end
end

# source://ruby_llm//lib/ruby_llm/message.rb#8
RubyLLM::Message::ROLES = T.let(T.unsafe(nil), Array)

# MimeTypes module provides methods to handle MIME types using Marcel gem
#
# source://ruby_llm//lib/ruby_llm/mime_type.rb#7
module RubyLLM::MimeType
  private

  # source://ruby_llm//lib/ruby_llm/mime_type.rb#18
  def audio?(type); end

  # source://ruby_llm//lib/ruby_llm/mime_type.rb#10
  def for(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/mime_type.rb#14
  def image?(type); end

  # source://ruby_llm//lib/ruby_llm/mime_type.rb#22
  def pdf?(type); end

  # source://ruby_llm//lib/ruby_llm/mime_type.rb#26
  def text?(type); end

  class << self
    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/mime_type.rb#18
    def audio?(type); end

    # source://ruby_llm//lib/ruby_llm/mime_type.rb#10
    def for(*_arg0, **_arg1, &_arg2); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/mime_type.rb#14
    def image?(type); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/mime_type.rb#22
    def pdf?(type); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/mime_type.rb#26
    def text?(type); end
  end
end

# MIME types that don't have a text/ prefix but should be treated as text
#
# source://ruby_llm//lib/ruby_llm/mime_type.rb#36
RubyLLM::MimeType::NON_TEXT_PREFIX_TEXT_MIME_TYPES = T.let(T.unsafe(nil), Array)

# MIME types that have a text/ prefix but need to be handled differently
#
# source://ruby_llm//lib/ruby_llm/mime_type.rb#33
RubyLLM::MimeType::TEXT_SUFFIXES = T.let(T.unsafe(nil), Array)

# Model-related classes for working with LLM models
#
# source://ruby_llm//lib/ruby_llm/model.rb#5
module RubyLLM::Model; end

# Information about an AI model's capabilities, pricing, and metadata.
# Used by the Models registry to help developers choose the right model
# for their needs.
#
# Example:
#   model = RubyLLM.models.find('gpt-4')
#   model.supports_vision?          # => true
#   model.supports_functions?       # => true
#   model.input_price_per_million   # => 30.0
#
# source://ruby_llm//lib/ruby_llm/model/info.rb#14
class RubyLLM::Model::Info
  # @return [Info] a new instance of Info
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#18
  def initialize(data); end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def batch?; end

  # Returns the value of attribute capabilities.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def citations?; end

  # Returns the value of attribute context_window.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def context_window; end

  # Returns the value of attribute created_at.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def created_at; end

  # Backward compatibility methods
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#45
  def display_name; end

  # Returns the value of attribute family.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def family; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def function_calling?; end

  # Returns the value of attribute id.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def id; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#61
  def input_price_per_million; end

  # Returns the value of attribute knowledge_cutoff.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def knowledge_cutoff; end

  # Returns the value of attribute max_output_tokens.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def max_output_tokens; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#49
  def max_tokens; end

  # Returns the value of attribute metadata.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def metadata; end

  # Returns the value of attribute modalities.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def modalities; end

  # Returns the value of attribute name.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def name; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#65
  def output_price_per_million; end

  # Returns the value of attribute pricing.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def pricing; end

  # Returns the value of attribute provider.
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#15
  def provider; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def reasoning?; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def streaming?; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#39
  def structured_output?; end

  # Capability methods
  #
  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#34
  def supports?(capability); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#57
  def supports_functions?; end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/info.rb#53
  def supports_vision?; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#83
  def to_h; end

  # source://ruby_llm//lib/ruby_llm/model/info.rb#69
  def type; end
end

# Holds and manages input and output modalities for a language model
#
# source://ruby_llm//lib/ruby_llm/model/modalities.rb#6
class RubyLLM::Model::Modalities
  # @return [Modalities] a new instance of Modalities
  #
  # source://ruby_llm//lib/ruby_llm/model/modalities.rb#9
  def initialize(data); end

  # Returns the value of attribute input.
  #
  # source://ruby_llm//lib/ruby_llm/model/modalities.rb#7
  def input; end

  # Returns the value of attribute output.
  #
  # source://ruby_llm//lib/ruby_llm/model/modalities.rb#7
  def output; end

  # source://ruby_llm//lib/ruby_llm/model/modalities.rb#14
  def to_h; end
end

# A collection that manages and provides access to different categories of pricing information
# (text tokens, images, audio tokens, embeddings)
#
# source://ruby_llm//lib/ruby_llm/model/pricing.rb#7
class RubyLLM::Model::Pricing
  # @return [Pricing] a new instance of Pricing
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing.rb#8
  def initialize(data); end

  # source://ruby_llm//lib/ruby_llm/model/pricing.rb#17
  def method_missing(method, *args); end

  # source://ruby_llm//lib/ruby_llm/model/pricing.rb#29
  def to_h; end

  private

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing.rb#35
  def empty_pricing?(data); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing.rb#25
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

# Represents pricing tiers for different usage categories (standard and batch)
#
# source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#6
class RubyLLM::Model::PricingCategory
  # @return [PricingCategory] a new instance of PricingCategory
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#9
  def initialize(data = T.unsafe(nil)); end

  # Get value for a specific tier
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#28
  def [](key); end

  # Returns the value of attribute batch.
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#7
  def batch; end

  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#23
  def cached_input; end

  # Shorthand methods that default to standard tier
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#15
  def input; end

  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#19
  def output; end

  # Returns the value of attribute standard.
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#7
  def standard; end

  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#32
  def to_h; end

  private

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_category.rb#41
  def empty_tier?(tier_data); end
end

# A dynamic class for storing non-zero pricing values with flexible attribute access
#
# source://ruby_llm//lib/ruby_llm/model/pricing_tier.rb#6
class RubyLLM::Model::PricingTier
  # @return [PricingTier] a new instance of PricingTier
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_tier.rb#7
  def initialize(data = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/model/pricing_tier.rb#16
  def method_missing(method, *args); end

  # source://ruby_llm//lib/ruby_llm/model/pricing_tier.rb#29
  def to_h; end

  private

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/model/pricing_tier.rb#25
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

# source://ruby_llm//lib/ruby_llm/error.rb#25
class RubyLLM::ModelNotFoundError < ::StandardError; end

# Registry of available AI models and their capabilities. Provides a clean interface
# to discover and work with models from different providers.
#
# Example:
#   RubyLLM.models.all                                  # All available models
#   RubyLLM.models.chat_models                          # Models that support chat
#   RubyLLM.models.by_provider('openai').chat_models    # OpenAI chat models
#   RubyLLM.models.find('claude-3')                     # Get info about a specific model
#
# source://ruby_llm//lib/ruby_llm/models.rb#12
class RubyLLM::Models
  include ::Enumerable

  # Initialize with optional pre-filtered models
  #
  # @return [Models] a new instance of Models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#141
  def initialize(models = T.unsafe(nil)); end

  # Return all models in the collection
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#158
  def all; end

  # Filter to only audio models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#187
  def audio_models; end

  # Filter models by family
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#197
  def by_family(family); end

  # Filter models by provider
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#202
  def by_provider(provider); end

  # Filter to only chat models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#177
  def chat_models; end

  # Allow enumeration over all models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#163
  def each(&_arg0); end

  # Filter to only embedding models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#182
  def embedding_models; end

  # Find a specific model by ID
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#168
  def find(model_id, provider = T.unsafe(nil)); end

  # Filter to only image models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#192
  def image_models; end

  # Load models from the JSON file
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#146
  def load_models; end

  # Instance method to refresh models
  #
  # source://ruby_llm//lib/ruby_llm/models.rb#207
  def refresh!; end

  # source://ruby_llm//lib/ruby_llm/models.rb#153
  def save_models; end

  private

  # source://ruby_llm//lib/ruby_llm/models.rb#213
  def find_with_provider(model_id, provider); end

  # source://ruby_llm//lib/ruby_llm/models.rb#220
  def find_without_provider(model_id); end

  class << self
    # source://ruby_llm//lib/ruby_llm/models.rb#132
    def add_provider_metadata(parsera_model, provider_model); end

    # source://ruby_llm//lib/ruby_llm/models.rb#87
    def fetch_from_parsera; end

    # source://ruby_llm//lib/ruby_llm/models.rb#39
    def fetch_from_providers; end

    # source://ruby_llm//lib/ruby_llm/models.rb#126
    def index_by_key(models); end

    # source://ruby_llm//lib/ruby_llm/models.rb#16
    def instance; end

    # source://ruby_llm//lib/ruby_llm/models.rb#98
    def merge_models(provider_models, parsera_models); end

    # source://ruby_llm//lib/ruby_llm/models.rb#75
    def method_missing(method, *_arg1, **_arg2, &_arg3); end

    # source://ruby_llm//lib/ruby_llm/models.rb#24
    def models_file; end

    # source://ruby_llm//lib/ruby_llm/models.rb#20
    def provider_for(model); end

    # source://ruby_llm//lib/ruby_llm/models.rb#28
    def refresh!; end

    # source://ruby_llm//lib/ruby_llm/models.rb#49
    def resolve(model_id, provider: T.unsafe(nil), assume_exists: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/models.rb#83
    def respond_to_missing?(method, include_private = T.unsafe(nil)); end
  end
end

# source://ruby_llm//lib/ruby_llm/error.rb#32
class RubyLLM::OverloadedError < ::RubyLLM::Error; end

# Parameter definition for Tool methods. Specifies type constraints,
# descriptions, and whether parameters are required.
#
# source://ruby_llm//lib/ruby_llm/tool.rb#6
class RubyLLM::Parameter
  # @return [Parameter] a new instance of Parameter
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#9
  def initialize(name, type: T.unsafe(nil), desc: T.unsafe(nil), required: T.unsafe(nil)); end

  # Returns the value of attribute description.
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#7
  def description; end

  # Returns the value of attribute name.
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#7
  def name; end

  # Returns the value of attribute required.
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#7
  def required; end

  # Returns the value of attribute type.
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#7
  def type; end
end

# source://ruby_llm//lib/ruby_llm/error.rb#33
class RubyLLM::PaymentRequiredError < ::RubyLLM::Error; end

# Base interface for LLM providers like OpenAI and Anthropic.
# Handles the complexities of API communication, streaming responses,
# and error handling so individual providers can focus on their unique features.
#
# source://ruby_llm//lib/ruby_llm/provider.rb#7
module RubyLLM::Provider
  # source://ruby_llm//lib/ruby_llm/provider.rb#116
  def connection(config); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#106
  def parse_data_uri(uri); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#90
  def parse_error(response); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#82
  def try_parse_json(maybe_json); end

  class << self
    # source://ruby_llm//lib/ruby_llm/provider.rb#147
    def configured_providers(config = T.unsafe(nil)); end

    # @private
    #
    # source://ruby_llm//lib/ruby_llm/provider.rb#121
    def extended(base); end

    # source://ruby_llm//lib/ruby_llm/provider.rb#130
    def for(model); end

    # source://ruby_llm//lib/ruby_llm/provider.rb#139
    def local_providers; end

    # source://ruby_llm//lib/ruby_llm/provider.rb#135
    def providers; end

    # source://ruby_llm//lib/ruby_llm/provider.rb#126
    def register(name, provider_module); end

    # source://ruby_llm//lib/ruby_llm/provider.rb#143
    def remote_providers; end
  end
end

# Common functionality for all LLM providers. Implements the core provider
# interface so specific providers only need to implement a few key methods.
#
# source://ruby_llm//lib/ruby_llm/provider.rb#10
module RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming

  # source://ruby_llm//lib/ruby_llm/provider.rb#13
  def complete(messages, tools:, temperature:, model:, connection:, &_arg5); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/provider.rb#46
  def configured?(config = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#34
  def embed(text, model:, connection:, dimensions:); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#29
  def list_models(connection:); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/provider.rb#58
  def local?; end

  # source://ruby_llm//lib/ruby_llm/provider.rb#51
  def missing_configs(config); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#40
  def paint(prompt, model:, size:, connection:); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/provider.rb#62
  def remote?; end

  private

  # source://ruby_llm//lib/ruby_llm/provider.rb#68
  def maybe_normalize_temperature(temperature, model); end

  # source://ruby_llm//lib/ruby_llm/provider.rb#76
  def sync_response(connection, payload); end
end

# source://ruby_llm//lib/ruby_llm.rb#0
module RubyLLM::Providers; end

# Anthropic Claude API integration. Handles the complexities of
# Claude's unique message format and tool calling conventions.
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#7
module RubyLLM::Providers::Anthropic
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::Anthropic::Chat
  extend ::RubyLLM::Providers::Anthropic::Embeddings
  extend ::RubyLLM::Providers::Anthropic::Media
  extend ::RubyLLM::Providers::Anthropic::Models
  extend ::RubyLLM::Providers::Anthropic::Streaming
  extend ::RubyLLM::Providers::Anthropic::Tools

  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#18
  def api_base(_config); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#29
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#37
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#22
  def headers(config); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#33
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#18
    def api_base(_config); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#29
    def capabilities; end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#37
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#22
    def headers(config); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic.rb#33
    def slug; end
  end
end

# Determines capabilities and pricing for Anthropic models
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#7
module RubyLLM::Providers::Anthropic::Capabilities
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#130
  def capabilities_for(model_id); end

  # Default input price if model not found in PRICES
  #
  # @return [Float] default price per million tokens for input
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#105
  def default_input_price; end

  # Default output price if model not found in PRICES
  #
  # @return [Float] default price per million tokens for output
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#111
  def default_output_price; end

  # Determines the context window size for a given model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the context window size in tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#13
  def determine_context_window(_model_id); end

  # Determines the maximum output tokens for a given model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the maximum output tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#21
  def determine_max_tokens(model_id); end

  # Gets the input price per million tokens for a given model
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens for input
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#31
  def get_input_price(model_id); end

  # Gets the output price per million tokens for a given model
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens for output
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#38
  def get_output_price(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#115
  def modalities_for(model_id); end

  # Determines the model family for a given model ID
  #
  # @param model_id [String] the model identifier
  # @return [Symbol] the model family identifier
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#74
  def model_family(model_id); end

  # Returns the model type
  #
  # @param model_id [String] the model identifier (unused but kept for API consistency)
  # @return [String] the model type, always 'chat' for Anthropic models
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#89
  def model_type(_); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#149
  def pricing_for(model_id); end

  # Determines if a model supports extended thinking
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports extended thinking
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#67
  def supports_extended_thinking?(model_id); end

  # Determines if a model supports function calling
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports functions
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#53
  def supports_functions?(model_id); end

  # Determines if a model supports JSON mode
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports JSON mode
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#60
  def supports_json_mode?(model_id); end

  # Determines if a model supports vision capabilities
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports vision
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#45
  def supports_vision?(model_id); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#130
    def capabilities_for(model_id); end

    # Default input price if model not found in PRICES
    #
    # @return [Float] default price per million tokens for input
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#105
    def default_input_price; end

    # Default output price if model not found in PRICES
    #
    # @return [Float] default price per million tokens for output
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#111
    def default_output_price; end

    # Determines the context window size for a given model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the context window size in tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#13
    def determine_context_window(_model_id); end

    # Determines the maximum output tokens for a given model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the maximum output tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#21
    def determine_max_tokens(model_id); end

    # Gets the input price per million tokens for a given model
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens for input
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#31
    def get_input_price(model_id); end

    # Gets the output price per million tokens for a given model
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens for output
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#38
    def get_output_price(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#115
    def modalities_for(model_id); end

    # Determines the model family for a given model ID
    #
    # @param model_id [String] the model identifier
    # @return [Symbol] the model family identifier
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#74
    def model_family(model_id); end

    # Returns the model type
    #
    # @param model_id [String] the model identifier (unused but kept for API consistency)
    # @return [String] the model type, always 'chat' for Anthropic models
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#89
    def model_type(_); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#149
    def pricing_for(model_id); end

    # Determines if a model supports extended thinking
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports extended thinking
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#67
    def supports_extended_thinking?(model_id); end

    # Determines if a model supports function calling
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports functions
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#53
    def supports_functions?(model_id); end

    # Determines if a model supports JSON mode
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports JSON mode
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#60
    def supports_json_mode?(model_id); end

    # Determines if a model supports vision capabilities
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports vision
    #
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#45
    def supports_vision?(model_id); end
  end
end

# Pricing information for Anthropic models (per million tokens)
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/capabilities.rb#94
RubyLLM::Providers::Anthropic::Capabilities::PRICES = T.let(T.unsafe(nil), Hash)

# Chat methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#7
module RubyLLM::Providers::Anthropic::Chat
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#48
  def add_optional_fields(payload, system_content:, tools:); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#38
  def build_base_payload(chat_messages, temperature, model, stream); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#68
  def build_message(data, content, tool_use); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#27
  def build_system_content(system_messages); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#10
  def completion_url; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#96
  def convert_role(role); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#63
  def extract_text_content(blocks); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#89
  def format_basic_message(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#79
  def format_message(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#53
  def parse_completion_response(response); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#14
  def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#23
  def separate_messages(messages); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#48
    def add_optional_fields(payload, system_content:, tools:); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#38
    def build_base_payload(chat_messages, temperature, model, stream); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#68
    def build_message(data, content, tool_use); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#27
    def build_system_content(system_messages); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#10
    def completion_url; end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#96
    def convert_role(role); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#63
    def extract_text_content(blocks); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#89
    def format_basic_message(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#79
    def format_message(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#53
    def parse_completion_response(response); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#14
    def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/chat.rb#23
    def separate_messages(messages); end
  end
end

# Embeddings methods of the Anthropic API integration
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/embeddings.rb#7
module RubyLLM::Providers::Anthropic::Embeddings
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/embeddings.rb#10
  def embed; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/embeddings.rb#10
  def embedding_url; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/embeddings.rb#10
  def parse_embedding_response; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/embeddings.rb#10
  def render_embedding_payload; end
end

# Handles formatting of media content (images, PDFs, audio) for Anthropic
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#7
module RubyLLM::Providers::Anthropic::Media
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#10
  def format_content(content); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#39
  def format_image(image); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#60
  def format_pdf(pdf); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#32
  def format_text(text); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#81
  def format_text_file(text_file); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#10
    def format_content(content); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#39
    def format_image(image); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#60
    def format_pdf(pdf); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#32
    def format_text(text); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/media.rb#81
    def format_text_file(text_file); end
  end
end

# Models methods of the Anthropic API integration
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#7
module RubyLLM::Providers::Anthropic::Models
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#38
  def extract_input_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#34
  def extract_model_id(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#42
  def extract_output_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#10
  def models_url; end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#14
  def parse_list_models_response(response, slug, capabilities); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#38
    def extract_input_tokens(data); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#34
    def extract_model_id(data); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#42
    def extract_output_tokens(data); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#10
    def models_url; end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/models.rb#14
    def parse_list_models_response(response, slug, capabilities); end
  end
end

# Streaming methods of the Anthropic API integration
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/streaming.rb#7
module RubyLLM::Providers::Anthropic::Streaming
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/streaming.rb#14
  def build_chunk(data); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/anthropic/streaming.rb#25
  def json_delta?(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/streaming.rb#29
  def parse_streaming_error(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/streaming.rb#10
  def stream_url; end
end

# Tools methods of the Anthropic API integration
#
# source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#7
module RubyLLM::Providers::Anthropic::Tools
  private

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#82
  def clean_parameters(parameters); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#62
  def extract_tool_calls(data); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#10
  def find_tool_use(blocks); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#14
  def format_tool_call(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#26
  def format_tool_result(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#42
  def format_tool_result_block(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#33
  def format_tool_use_block(tool_call); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#50
  def function_for(tool); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#70
  def parse_tool_calls(content_block); end

  # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#91
  def required_parameters(parameters); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#82
    def clean_parameters(parameters); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#62
    def extract_tool_calls(data); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#10
    def find_tool_use(blocks); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#14
    def format_tool_call(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#26
    def format_tool_result(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#42
    def format_tool_result_block(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#33
    def format_tool_use_block(tool_call); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#50
    def function_for(tool); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#70
    def parse_tool_calls(content_block); end

    # source://ruby_llm//lib/ruby_llm/providers/anthropic/tools.rb#91
    def required_parameters(parameters); end
  end
end

# AWS Bedrock API integration. Handles chat completion and streaming
# for Claude models.
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#10
module RubyLLM::Providers::Bedrock
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::Bedrock::Chat
  extend ::RubyLLM::Providers::Bedrock::Streaming::Base
  extend ::RubyLLM::Providers::Bedrock::Streaming::ContentExtraction
  extend ::RubyLLM::Providers::Bedrock::Streaming::MessageProcessing
  extend ::RubyLLM::Providers::Bedrock::Streaming::PayloadProcessing
  extend ::RubyLLM::Providers::Bedrock::Streaming::PreludeHandling
  extend ::RubyLLM::Providers::Bedrock::Streaming
  extend ::RubyLLM::Providers::Bedrock::Models
  extend ::RubyLLM::Providers::Bedrock::Signing
  extend ::RubyLLM::Providers::Bedrock::Media
  extend ::RubyLLM::Providers::Anthropic::Tools

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#21
  def api_base(config); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#66
  def build_headers(signature_headers, streaming: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#57
  def build_request(url, config:, method: T.unsafe(nil), payload: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#75
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#83
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#47
  def create_signer(config); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#25
  def parse_error(response); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#41
  def sign_request(url, config:, method: T.unsafe(nil), payload: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#79
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#21
    def api_base(config); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#66
    def build_headers(signature_headers, streaming: T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#57
    def build_request(url, config:, method: T.unsafe(nil), payload: T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#75
    def capabilities; end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#83
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#47
    def create_signer(config); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#25
    def parse_error(response); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#41
    def sign_request(url, config:, method: T.unsafe(nil), payload: T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock.rb#79
    def slug; end
  end
end

# Determines capabilities and pricing for AWS Bedrock models
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#7
module RubyLLM::Providers::Bedrock::Capabilities
  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#179
  def capabilities_for(model_id); end

  # Returns the context window size for the given model ID
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the context window size in tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#13
  def context_window_for(model_id); end

  # Default input price when model-specific pricing is not available
  #
  # @return [Float] the default price per million tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#142
  def default_input_price; end

  # Default output price when model-specific pricing is not available
  #
  # @return [Float] the default price per million tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#148
  def default_output_price; end

  # Formats the model ID into a human-readable display name
  #
  # @param model_id [String] the model identifier
  # @return [String] the formatted display name
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#93
  def format_display_name(model_id); end

  # Converts a model ID to a human-readable format
  #
  # @param id [String] the model identifier
  # @return [String] the humanized model name
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#155
  def humanize(id); end

  # Returns the input price per million tokens for the given model ID
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens for input
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#30
  def input_price_for(model_id); end

  # Returns the maximum output tokens for the given model ID
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the maximum output tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#23
  def max_tokens_for(_model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#164
  def modalities_for(model_id); end

  # Determines the model family for pricing and capability lookup
  #
  # @param model_id [String] the model identifier
  # @return [Symbol] the model family identifier
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#126
  def model_family(model_id); end

  # Determines the type of model
  #
  # @param model_id [String] the model identifier
  # @return [String] the model type (chat, embedding, image, audio)
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#100
  def model_type(_model_id); end

  # Returns the output price per million tokens for the given model ID
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens for output
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#37
  def output_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#202
  def pricing_for(model_id); end

  # Determines if the model supports audio input/output
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports audio
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#79
  def supports_audio?(_model_id); end

  # Determines if the model supports chat capabilities
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports chat
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#44
  def supports_chat?(model_id); end

  # Determines if the model supports function calling
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports functions
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#72
  def supports_functions?(model_id); end

  # Determines if the model supports image input/output
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports images
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#58
  def supports_images?(model_id); end

  # Determines if the model supports JSON mode
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports JSON mode
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#86
  def supports_json_mode?(model_id); end

  # Determines if the model supports streaming capabilities
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports streaming
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#51
  def supports_streaming?(model_id); end

  # Determines if the model supports structured output
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports structured output
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#107
  def supports_structured_output?(model_id); end

  # Determines if the model supports vision capabilities
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports vision
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#65
  def supports_vision?(model_id); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#179
    def capabilities_for(model_id); end

    # Returns the context window size for the given model ID
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the context window size in tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#13
    def context_window_for(model_id); end

    # Default input price when model-specific pricing is not available
    #
    # @return [Float] the default price per million tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#142
    def default_input_price; end

    # Default output price when model-specific pricing is not available
    #
    # @return [Float] the default price per million tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#148
    def default_output_price; end

    # Formats the model ID into a human-readable display name
    #
    # @param model_id [String] the model identifier
    # @return [String] the formatted display name
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#93
    def format_display_name(model_id); end

    # Converts a model ID to a human-readable format
    #
    # @param id [String] the model identifier
    # @return [String] the humanized model name
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#155
    def humanize(id); end

    # Returns the input price per million tokens for the given model ID
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens for input
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#30
    def input_price_for(model_id); end

    # Returns the maximum output tokens for the given model ID
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the maximum output tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#23
    def max_tokens_for(_model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#164
    def modalities_for(model_id); end

    # Determines the model family for pricing and capability lookup
    #
    # @param model_id [String] the model identifier
    # @return [Symbol] the model family identifier
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#126
    def model_family(model_id); end

    # Determines the type of model
    #
    # @param model_id [String] the model identifier
    # @return [String] the model type (chat, embedding, image, audio)
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#100
    def model_type(_model_id); end

    # Returns the output price per million tokens for the given model ID
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens for output
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#37
    def output_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#202
    def pricing_for(model_id); end

    # Determines if the model supports audio input/output
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports audio
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#79
    def supports_audio?(_model_id); end

    # Determines if the model supports chat capabilities
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports chat
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#44
    def supports_chat?(model_id); end

    # Determines if the model supports function calling
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports functions
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#72
    def supports_functions?(model_id); end

    # Determines if the model supports image input/output
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports images
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#58
    def supports_images?(model_id); end

    # Determines if the model supports JSON mode
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports JSON mode
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#86
    def supports_json_mode?(model_id); end

    # Determines if the model supports streaming capabilities
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports streaming
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#51
    def supports_streaming?(model_id); end

    # Determines if the model supports structured output
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports structured output
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#107
    def supports_structured_output?(model_id); end

    # Determines if the model supports vision capabilities
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports vision
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#65
    def supports_vision?(model_id); end
  end
end

# Model family patterns for capability lookup
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#112
RubyLLM::Providers::Bedrock::Capabilities::MODEL_FAMILIES = T.let(T.unsafe(nil), Hash)

# Pricing information for Bedrock models (per million tokens)
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/capabilities.rb#131
RubyLLM::Providers::Bedrock::Capabilities::PRICES = T.let(T.unsafe(nil), Hash)

# Chat methods for the AWS Bedrock API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#7
module RubyLLM::Providers::Bedrock::Chat
  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#54
  def build_base_payload(chat_messages, temperature, model); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#38
  def completion_url; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#29
  def format_basic_message(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#19
  def format_message(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#42
  def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#10
  def sync_response(connection, payload); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#29
    def format_basic_message(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#19
    def format_message(msg); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/chat.rb#10
    def sync_response(connection, payload); end
  end
end

# Media handling methods for the Bedrock API integration
# NOTE: Bedrock does not support url attachments
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#8
module RubyLLM::Providers::Bedrock::Media
  extend ::RubyLLM::Providers::Anthropic::Media

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#13
  def format_content(content); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#35
  def format_image(image); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#46
  def format_pdf(pdf); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#13
    def format_content(content); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#35
    def format_image(image); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/media.rb#46
    def format_pdf(pdf); end
  end
end

# Models methods for the AWS Bedrock API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#7
module RubyLLM::Providers::Bedrock::Models
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#8
  def list_models(connection:); end

  private

  # Simple test-friendly method that only sets the ID
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#56
  def create_model_info(model_data, slug, _capabilities); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#74
  def model_id_with_region(model_id, model_data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#22
  def models_url; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#26
  def parse_list_models_response(response, slug, capabilities); end

  class << self
    # Simple test-friendly method that only sets the ID
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#56
    def create_model_info(model_data, slug, _capabilities); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#74
    def model_id_with_region(model_id, model_data); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#22
    def models_url; end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/models.rb#26
    def parse_list_models_response(response, slug, capabilities); end
  end
end

# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#18
module RubyLLM::Providers::Bedrock::Signing; end

# Handles canonical requests for AWS signature
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#257
class RubyLLM::Providers::Bedrock::Signing::CanonicalRequest
  # Builds a canonical request for AWS signature
  #
  # @param params [Hash] Parameters for the canonical request
  # @return [CanonicalRequest] a new instance of CanonicalRequest
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#260
  def initialize(params = T.unsafe(nil)); end

  # Returns the list of signed headers for authorization
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#280
  def signed_headers; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#268
  def to_s; end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#314
  def canonical_header_value(value); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#302
  def canonical_headers; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#292
  def path; end
end

# Configuration for canonical request creation
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#247
class RubyLLM::Providers::Bedrock::Signing::CanonicalRequestConfig
  # @return [CanonicalRequestConfig] a new instance of CanonicalRequestConfig
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#250
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute unsigned_headers.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#248
  def unsigned_headers; end

  # Returns the value of attribute uri_escape_path.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#248
  def uri_escape_path; end
end

# Credential management and fetching
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#490
class RubyLLM::Providers::Bedrock::Signing::CredentialManager
  # @return [CredentialManager] a new instance of CredentialManager
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#491
  def initialize(credentials_provider); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#507
  def credentials_set?(credentials); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#495
  def fetch_credentials; end
end

# Manages AWS credentials for authentication
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#134
class RubyLLM::Providers::Bedrock::Signing::Credentials
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Credentials] a new instance of Credentials
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#138
  def initialize(options = T.unsafe(nil)); end

  # @return [String]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#150
  def access_key_id; end

  # @return [String]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#153
  def secret_access_key; end

  # @return [String, nil]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#156
  def session_token; end

  # @return [Boolean] Returns `true` if the access key id and secret
  #   access key are both set.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#160
  def set?; end
end

# Cryptographic hash and digest utilities
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#228
module RubyLLM::Providers::Bedrock::Signing::CryptoUtils
  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#241
  def hexhmac(key, value); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#237
  def hmac(key, value); end

  # @param value [String]
  # @return [String<SHA256 Hexdigest>]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#233
  def sha256_hexdigest(value); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#241
    def hexhmac(key, value); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#237
    def hmac(key, value); end

    # @param value [String]
    # @return [String<SHA256 Hexdigest>]
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#233
    def sha256_hexdigest(value); end
  end
end

# Utility class for creating AWS signature version 4 signature. This class
# provides a method for generating signatures:
#
# * {#sign_request} - Computes a signature of the given request, returning
#   the hash of headers that should be applied to the request.
#
# ## Configuration
#
# To use the signer, you need to specify the service, region, and credentials.
# The service name is normally the endpoint prefix to an AWS service. For
# example:
#
#     ec2.us-west-1.amazonaws.com => ec2
#
# The region is normally the second portion of the endpoint, following
# the service name.
#
#     ec2.us-west-1.amazonaws.com => us-west-1
#
# It is important to have the correct service and region name, or the
# signature will be invalid.
#
# ## Credentials
#
# The signer requires credentials. You can configure the signer
# with static credentials:
#
#     signer = Aws::Sigv4::Signer.new(
#       service: 's3',
#       region: 'us-east-1',
#       # static credentials
#       access_key_id: 'akid',
#       secret_access_key: 'secret'
#     )
#
# You can also provide refreshing credentials via the `:credentials_provider`.
# If you are using the AWS SDK for Ruby, you can use any of the credential
# classes:
#
#     signer = Aws::Sigv4::Signer.new(
#       service: 's3',
#       region: 'us-east-1',
#       credentials_provider: Aws::InstanceProfileCredentials.new
#     )
#
# Other AWS SDK for Ruby classes that can be provided via `:credentials_provider`:
#
# * `Aws::Credentials`
# * `Aws::SharedCredentials`
# * `Aws::InstanceProfileCredentials`
# * `Aws::AssumeRoleCredentials`
# * `Aws::ECSCredentials`
#
# A credential provider is any object that responds to `#credentials`
# returning another object that responds to `#access_key_id`, `#secret_access_key`,
# and `#session_token`.
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#75
module RubyLLM::Providers::Bedrock::Signing::Errors; end

# Error raised when AWS credentials are missing or incomplete
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#77
class RubyLLM::Providers::Bedrock::Signing::Errors::MissingCredentialsError < ::ArgumentError
  # @return [MissingCredentialsError] a new instance of MissingCredentialsError
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#78
  def initialize(msg = T.unsafe(nil)); end
end

# Error raised when AWS region is not specified
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#89
class RubyLLM::Providers::Bedrock::Signing::Errors::MissingRegionError < ::ArgumentError
  # @return [MissingRegionError] a new instance of MissingRegionError
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#90
  def initialize(*_args); end
end

# Handles generating headers for AWS request signing
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#424
class RubyLLM::Providers::Bedrock::Signing::HeaderBuilder
  # @return [HeaderBuilder] a new instance of HeaderBuilder
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#425
  def initialize(options = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#462
  def build_authorization_header(signature); end

  # Build authorization headers for a signature
  #
  # @param sigv4_headers [Hash] Headers for the signature
  # @param signature [Hash] The computed signature
  # @param components [Hash] Request components
  # @return [Hash] Headers with authorization
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#453
  def build_headers(sigv4_headers, signature, components); end

  # Build headers for a signed request
  #
  # @param components [Hash] Request components
  # @param creds [Credentials] AWS credentials
  # @return [Hash] Generated headers
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#436
  def build_sigv4_headers(components, creds); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#478
  def add_content_sha256_header(headers, content_sha256); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#482
  def add_omitted_session_token(headers, creds); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#472
  def add_session_token_header(headers, creds); end
end

# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#189
class RubyLLM::Providers::Bedrock::Signing::ParamComponent < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute offset
  #
  # @return [Object] the current value of offset
  def offset; end

  # Sets the attribute offset
  #
  # @param value [Object] the value to set the attribute offset to.
  # @return [Object] the newly set value
  def offset=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Extracts and validates request components
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#359
class RubyLLM::Providers::Bedrock::Signing::RequestExtractor
  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#378
    def build_component_hash(http_method, url, headers, datetime, content_sha256); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#418
    def downcase_headers(headers); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#389
    def extract_base_components(request); end

    # Extract and process request components
    #
    # @param request [Hash] The request to process
    # @param options [Hash] Options for extraction
    # @return [Hash] Processed request components
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#364
    def extract_components(request, options = T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#396
    def extract_content_sha256(headers, body); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#400
    def extract_http_method(request); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#409
    def extract_url(request); end
  end
end

# Represents a signature for AWS request signing
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#97
class RubyLLM::Providers::Bedrock::Signing::Signature
  # @api private
  # @return [Signature] a new instance of Signature
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#99
  def initialize(options); end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#118
  def canonical_request; end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#118
  def canonical_request=(_arg0); end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#124
  def content_sha256; end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#124
  def content_sha256=(_arg0); end

  # @return [Hash] Internal data for debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#130
  def extra; end

  # @return [Hash] Internal data for debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#130
  def extra=(_arg0); end

  # @return [Hash<String,String>] A hash of headers that should
  #   be applied to the HTTP request. Header keys are lower
  #   cased strings and may include the following:
  #
  #   * 'host'
  #   * 'x-amz-date'
  #   * 'x-amz-security-token'
  #   * 'x-amz-content-sha256'
  #   * 'authorization'
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#115
  def headers; end

  # @return [Hash<String,String>] A hash of headers that should
  #   be applied to the HTTP request. Header keys are lower
  #   cased strings and may include the following:
  #
  #   * 'host'
  #   * 'x-amz-date'
  #   * 'x-amz-security-token'
  #   * 'x-amz-content-sha256'
  #   * 'authorization'
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#115
  def headers=(_arg0); end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#127
  def signature; end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#127
  def signature=(_arg0); end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#121
  def string_to_sign; end

  # @return [String] For debugging purposes.
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#121
  def string_to_sign=(_arg0); end
end

# Handles signature computation
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#320
class RubyLLM::Providers::Bedrock::Signing::SignatureComputation
  # @return [SignatureComputation] a new instance of SignatureComputation
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#321
  def initialize(service, region, signing_algorithm); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#345
  def credential(credentials, date); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#336
  def credential_scope(date); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#349
  def signature(secret_access_key, date, string_to_sign); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#327
  def string_to_sign(datetime, canonical_request, algorithm); end
end

# Core functionality for computing signatures
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#547
class RubyLLM::Providers::Bedrock::Signing::SignatureGenerator
  # @return [SignatureGenerator] a new instance of SignatureGenerator
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#548
  def initialize(options = T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#563
  def compute_signature(components, creds, sigv4_headers); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#559
  def sts_algorithm; end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#591
  def build_signature_result(components, creds, canonical_request, sig, algorithm); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#577
  def compute_signature_from_request(canonical_request, components, creds, algorithm); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#603
  def create_canonical_request(components, headers); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#615
  def create_canonical_request_config; end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#622
  def generate_signature(creds, date, string_to_sign); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#583
  def generate_string_to_sign(components, creq, algorithm); end
end

# Result builder for signature computation
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#516
class RubyLLM::Providers::Bedrock::Signing::SignatureResultBuilder
  # @return [SignatureResultBuilder] a new instance of SignatureResultBuilder
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#517
  def initialize(signature_computation); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#521
  def build_result(request_data); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#538
  def credential_from_request(request_data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#527
  def result_hash(request_data); end
end

# Handles AWS request signing using SigV4 or SigV4a
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#728
class RubyLLM::Providers::Bedrock::Signing::Signer
  # Initialize a new signer with the provided options
  #
  # @param options [Hash] Configuration options for the signer
  # @return [Signer] a new instance of Signer
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#731
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#750
  def apply_checksum_header; end

  # @return [#credentials]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#744
  def credentials_provider; end

  # @return [String]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#741
  def region; end

  # @return [String]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#738
  def service; end

  # Sign an AWS request with SigV4 or SigV4a
  #
  # @param request [Hash] The request to sign
  # @return [Signature] The signature with headers to apply
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#755
  def sign_request(request); end

  # @return [Set<String>]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#747
  def unsigned_headers; end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#802
  def build_signature_response(components, sigv4_headers, signature); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#790
  def build_sigv4_headers(request_components, creds); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#794
  def compute_signature(request_components, creds, sigv4_headers); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#783
  def extract_request_components(request); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#765
  def setup_configuration(components); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#777
  def setup_service_components(components); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#823
    def normalize_path(uri); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#819
    def uri_escape(string); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#815
    def uri_escape_path(path); end
  end
end

# Handles initialization of Signer dependencies
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#661
class RubyLLM::Providers::Bedrock::Signing::SignerInitializer
  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#662
    def create_components(options = T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#717
    def create_header_builder(components); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#695
    def create_service_components(components); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#707
    def create_signature_generator(components); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#686
    def extract_config_options(options); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#678
    def extract_core_components(options); end
  end
end

# Utility for extracting options and config
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#628
class RubyLLM::Providers::Bedrock::Signing::SignerOptionExtractor
  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#644
    def extract_credentials_provider(options); end

    # @raise [Errors::MissingRegionError]
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#638
    def extract_region(options); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#629
    def extract_service(options); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#654
    def initialize_unsigned_headers(options); end
  end
end

# Users that wish to configure static credentials can use the
# `:access_key_id` and `:secret_access_key` constructor options.
#
# @api private
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#171
class RubyLLM::Providers::Bedrock::Signing::StaticCredentialsProvider
  # @api private
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [StaticCredentialsProvider] a new instance of StaticCredentialsProvider
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#176
  def initialize(options = T.unsafe(nil)); end

  # @api private
  # @return [Credentials]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#181
  def credentials; end

  # @api private
  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#184
  def set?; end
end

# Utility methods for URI manipulation and hashing
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#192
module RubyLLM::Providers::Bedrock::Signing::UriUtils
  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#217
  def host(uri); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#207
  def normalize_path(uri); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#199
  def uri_escape(string); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#195
  def uri_escape_path(path); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#217
    def host(uri); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#207
    def normalize_path(uri); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#199
    def uri_escape(string); end

    # source://ruby_llm//lib/ruby_llm/providers/bedrock/signing.rb#195
    def uri_escape_path(path); end
  end
end

# Streaming implementation for the AWS Bedrock API.
# This module provides functionality for handling streaming responses from AWS Bedrock,
# including message processing, content extraction, and error handling.
#
# The implementation is split into several focused modules:
# - Base: Core streaming functionality and module coordination
# - ContentExtraction: Extracting content from response data
# - MessageProcessing: Processing streaming message chunks
# - PayloadProcessing: Handling JSON payloads and chunk creation
# - PreludeHandling: Managing message preludes and headers
#
# @example Using the streaming module
#   class BedrockClient
#   include RubyLLM::Providers::Bedrock::Streaming
#
#   def stream_response(&block)
#   handle_stream(&block)
#   end
#   end
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#6
module RubyLLM::Providers::Bedrock::Streaming
  include ::RubyLLM::Providers::Bedrock::Streaming::Base
  include ::RubyLLM::Providers::Bedrock::Streaming::ContentExtraction
  include ::RubyLLM::Providers::Bedrock::Streaming::MessageProcessing
  include ::RubyLLM::Providers::Bedrock::Streaming::PayloadProcessing
  include ::RubyLLM::Providers::Bedrock::Streaming::PreludeHandling
end

# Base module for AWS Bedrock streaming functionality.
# Serves as the core module that includes all other streaming-related modules
# and provides fundamental streaming operations.
#
# Responsibilities:
# - Stream URL management
# - Stream handling and error processing
# - Coordinating the functionality of other streaming modules
#
# @example
#   module MyStreamingImplementation
#   include RubyLLM::Providers::Bedrock::Streaming::Base
#   end
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#20
module RubyLLM::Providers::Bedrock::Streaming::Base
  include ::RubyLLM::Providers::Bedrock::Streaming::ContentExtraction
  include ::RubyLLM::Providers::Bedrock::Streaming::MessageProcessing
  include ::RubyLLM::Providers::Bedrock::Streaming::PayloadProcessing
  include ::RubyLLM::Providers::Bedrock::Streaming::PreludeHandling

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#48
  def handle_stream(&block); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#32
  def stream_response(connection, payload, &block); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#28
  def stream_url; end

  class << self
    # @private
    #
    # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/base.rb#21
    def included(base); end
  end
end

# Module for handling content extraction from AWS Bedrock streaming responses.
# Provides methods to extract and process various types of content from the response data.
#
# Responsibilities:
# - Extracting content from different response formats
# - Processing JSON deltas and content blocks
# - Extracting metadata (tokens, model IDs, tool calls)
# - Handling different content structures (arrays, blocks, completions)
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#15
module RubyLLM::Providers::Bedrock::Streaming::ContentExtraction
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#34
  def extract_input_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#30
  def extract_model_id(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#38
  def extract_output_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#20
  def extract_streaming_content(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#26
  def extract_tool_calls(data); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#16
  def json_delta?(data); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#52
  def extract_block_start_content(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#44
  def extract_content_by_type(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/content_extraction.rb#56
  def extract_delta_content(data); end
end

# Module for processing streaming messages from AWS Bedrock.
# Handles the core message processing logic, including validation and chunking.
#
# Responsibilities:
# - Processing incoming message chunks
# - Validating message structure and content
# - Managing message offsets and boundaries
# - Error handling during message processing
#
# @example Processing a message chunk
#   offset = process_message(chunk, current_offset) do |processed_chunk|
#   handle_processed_chunk(processed_chunk)
#   end
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#20
module RubyLLM::Providers::Bedrock::Streaming::MessageProcessing
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#21
  def process_chunk(chunk, &_arg1); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#29
  def process_message(chunk, offset, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#38
  def process_valid_message(chunk, offset, message_info, &_arg3); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#48
  def extract_message_info(chunk, offset); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#61
  def extract_payload(chunk, headers_end, payload_end); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/message_processing.rb#65
  def valid_payload?(payload); end
end

# Module for processing payloads from AWS Bedrock streaming responses.
# Handles JSON payload extraction, decoding, and chunk creation.
#
# Responsibilities:
# - Extracting and validating JSON payloads
# - Decoding Base64-encoded response data
# - Creating response chunks from processed data
# - Error handling for JSON parsing and processing
#
# @example Processing a payload
#   process_payload(raw_payload) do |chunk|
#   yield_chunk_to_client(chunk)
#   end
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#22
module RubyLLM::Providers::Bedrock::Streaming::PayloadProcessing
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#23
  def process_payload(payload, &_arg1); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#61
  def build_chunk(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#57
  def create_and_yield_chunk(data, &block); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#52
  def decode_and_parse_data(json_data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#67
  def extract_chunk_attributes(data); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#34
  def extract_json_payload(payload); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#83
  def log_general_error(error); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#78
  def log_json_parse_error(error, json_payload); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#40
  def parse_and_process_json(json_payload, &_arg1); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/payload_processing.rb#45
  def process_json_data(json_data, &_arg1); end
end

# Module for handling message preludes in AWS Bedrock streaming responses.
# Manages the parsing and validation of message headers and prelude data.
#
# Responsibilities:
# - Reading and validating message preludes
# - Calculating message positions and boundaries
# - Finding and validating prelude positions in chunks
# - Ensuring message integrity through length validation
#
# @example Reading a prelude
#   if can_read_prelude?(chunk, offset)
#   total_length, headers_length = read_prelude(chunk, offset)
#   process_message_with_lengths(total_length, headers_length)
#   end
#
# source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#21
module RubyLLM::Providers::Bedrock::Streaming::PreludeHandling
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#36
  def calculate_positions(offset, total_length, headers_length); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#22
  def can_read_prelude?(chunk, offset); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#50
  def find_next_message(chunk, offset); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#55
  def find_next_prelude(chunk, start_offset); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#26
  def read_prelude(chunk, offset); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#32
  def valid_lengths?(total_length, headers_length); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#42
  def valid_positions?(headers_end, payload_end, chunk_size); end

  private

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#73
  def extract_potential_lengths(chunk, pos); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#64
  def scan_range(chunk, start_offset); end

  # @return [Boolean]
  #
  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#68
  def valid_prelude_at_position?(chunk, pos); end

  # source://ruby_llm//lib/ruby_llm/providers/bedrock/streaming/prelude_handling.rb#80
  def validate_length_constraints(total_length, headers_length); end
end

# DeepSeek API integration.
#
# source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#6
module RubyLLM::Providers::DeepSeek
  extend ::RubyLLM::Providers::OpenAI
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::OpenAI::Chat
  extend ::RubyLLM::Providers::OpenAI::Embeddings
  extend ::RubyLLM::Providers::OpenAI::Models
  extend ::RubyLLM::Providers::OpenAI::Streaming
  extend ::RubyLLM::Providers::OpenAI::Tools
  extend ::RubyLLM::Providers::OpenAI::Images
  extend ::RubyLLM::Providers::OpenAI::Media
  extend ::RubyLLM::Providers::DeepSeek::Chat

  private

  # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#12
  def api_base(_config); end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#22
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#30
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#16
  def headers(config); end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#26
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#12
    def api_base(_config); end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#22
    def capabilities; end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#30
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#16
    def headers(config); end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek.rb#26
    def slug; end
  end
end

# Determines capabilities and pricing for DeepSeek models
#
# source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#7
module RubyLLM::Providers::DeepSeek::Capabilities
  private

  # Returns the price per million tokens for input with cache hit
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens in USD
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#47
  def cache_hit_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#142
  def capabilities_for(model_id); end

  # Returns the context window size for the given model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the context window size in tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#13
  def context_window_for(model_id); end

  # Default cache hit price when model family can't be determined
  #
  # @return [Float] the default cache hit price
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#131
  def default_cache_hit_price; end

  # Default input price when model family can't be determined
  #
  # @return [Float] the default input price
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#119
  def default_input_price; end

  # Default output price when model family can't be determined
  #
  # @return [Float] the default output price
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#125
  def default_output_price; end

  # Returns a formatted display name for the model
  #
  # @param model_id [String] the model identifier
  # @return [String] the formatted display name
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#75
  def format_display_name(model_id); end

  # Returns the price per million tokens for input (cache miss)
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens in USD
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#33
  def input_price_for(model_id); end

  # Returns the maximum number of tokens that can be generated
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the maximum number of tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#23
  def max_tokens_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#135
  def modalities_for(_model_id); end

  # Returns the model family
  #
  # @param model_id [String] the model identifier
  # @return [Symbol] the model family
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#96
  def model_family(model_id); end

  # Returns the model type
  #
  # @param model_id [String] the model identifier
  # @return [String] the model type (e.g., 'chat')
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#89
  def model_type(_model_id); end

  # Returns the price per million tokens for output
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens in USD
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#40
  def output_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#151
  def pricing_for(model_id); end

  # Determines if the model supports function calling
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports function calling
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#61
  def supports_functions?(model_id); end

  # Determines if the model supports JSON mode
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports JSON mode
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#68
  def supports_json_mode?(_model_id); end

  # Determines if the model supports vision capabilities
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports vision
  #
  # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#54
  def supports_vision?(_model_id); end

  class << self
    # Returns the price per million tokens for input with cache hit
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens in USD
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#47
    def cache_hit_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#142
    def capabilities_for(model_id); end

    # Returns the context window size for the given model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the context window size in tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#13
    def context_window_for(model_id); end

    # Default cache hit price when model family can't be determined
    #
    # @return [Float] the default cache hit price
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#131
    def default_cache_hit_price; end

    # Default input price when model family can't be determined
    #
    # @return [Float] the default input price
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#119
    def default_input_price; end

    # Default output price when model family can't be determined
    #
    # @return [Float] the default output price
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#125
    def default_output_price; end

    # Returns a formatted display name for the model
    #
    # @param model_id [String] the model identifier
    # @return [String] the formatted display name
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#75
    def format_display_name(model_id); end

    # Returns the price per million tokens for input (cache miss)
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens in USD
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#33
    def input_price_for(model_id); end

    # Returns the maximum number of tokens that can be generated
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the maximum number of tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#23
    def max_tokens_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#135
    def modalities_for(_model_id); end

    # Returns the model family
    #
    # @param model_id [String] the model identifier
    # @return [Symbol] the model family
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#96
    def model_family(model_id); end

    # Returns the model type
    #
    # @param model_id [String] the model identifier
    # @return [String] the model type (e.g., 'chat')
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#89
    def model_type(_model_id); end

    # Returns the price per million tokens for output
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens in USD
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#40
    def output_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#151
    def pricing_for(model_id); end

    # Determines if the model supports function calling
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports function calling
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#61
    def supports_functions?(model_id); end

    # Determines if the model supports JSON mode
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports JSON mode
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#68
    def supports_json_mode?(_model_id); end

    # Determines if the model supports vision capabilities
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports vision
    #
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#54
    def supports_vision?(_model_id); end
  end
end

# Pricing information for DeepSeek models (USD per 1M tokens)
#
# source://ruby_llm//lib/ruby_llm/providers/deepseek/capabilities.rb#104
RubyLLM::Providers::DeepSeek::Capabilities::PRICES = T.let(T.unsafe(nil), Hash)

# Chat methods of the DeepSeek API integration
#
# source://ruby_llm//lib/ruby_llm/providers/deepseek/chat.rb#7
module RubyLLM::Providers::DeepSeek::Chat
  private

  # source://ruby_llm//lib/ruby_llm/providers/deepseek/chat.rb#10
  def format_role(role); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/deepseek/chat.rb#10
    def format_role(role); end
  end
end

# Native Gemini API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/gemini.rb#6
module RubyLLM::Providers::Gemini
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::Gemini::Chat
  extend ::RubyLLM::Providers::Gemini::Embeddings
  extend ::RubyLLM::Providers::Gemini::Images
  extend ::RubyLLM::Providers::Gemini::Models
  extend ::RubyLLM::Providers::Gemini::Streaming
  extend ::RubyLLM::Providers::Gemini::Tools
  extend ::RubyLLM::Providers::Gemini::Media

  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#18
  def api_base(_config); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#28
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#36
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#22
  def headers(config); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#32
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#18
    def api_base(_config); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#28
    def capabilities; end

    # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#36
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#22
    def headers(config); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini.rb#32
    def slug; end
  end
end

# Determines capabilities and pricing for Google Gemini models
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#7
module RubyLLM::Providers::Gemini::Capabilities
  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#286
  def capabilities_for(model_id); end

  # Returns the context length for the model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the context length in tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#193
  def context_length(model_id); end

  # Returns the context window size (input token limit) for the given model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the context window size in tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#13
  def context_window_for(model_id); end

  # Default input price for unknown models
  #
  # @return [Float] the default input price per million tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#255
  def default_input_price; end

  # Default output price for unknown models
  #
  # @return [Float] the default output price per million tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#261
  def default_output_price; end

  # Formats the model ID into a human-readable display name
  #
  # @param model_id [String] the model identifier
  # @return [String] the formatted display name
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#96
  def format_display_name(model_id); end

  # Returns the input price per million tokens for the given model
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens in USD
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#45
  def input_price_for(model_id); end

  # Determines if the model supports long context
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports long context
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#186
  def long_context_model?(model_id); end

  # Returns the maximum output tokens for the given model
  #
  # @param model_id [String] the model identifier
  # @return [Integer] the maximum output tokens
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#29
  def max_tokens_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#265
  def modalities_for(model_id); end

  # Returns the model family identifier
  #
  # @param model_id [String] the model identifier
  # @return [String] the model family identifier
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#147
  def model_family(model_id); end

  # Returns the type of model (chat, embedding, image)
  #
  # @param model_id [String] the model identifier
  # @return [String] the model type
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#136
  def model_type(model_id); end

  # Returns the output price per million tokens for the given model
  #
  # @param model_id [String] the model identifier
  # @return [Float] the price per million tokens in USD
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#56
  def output_price_for(model_id); end

  # Returns the pricing family identifier for the model
  #
  # @param model_id [String] the model identifier
  # @return [Symbol] the pricing family identifier
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#167
  def pricing_family(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#307
  def pricing_for(model_id); end

  # Determines if the model supports audio inputs
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports audio inputs
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#129
  def supports_audio?(model_id); end

  # Determines if the model supports context caching
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports caching
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#111
  def supports_caching?(model_id); end

  # Determines if the model supports function calling
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports function calling
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#76
  def supports_functions?(model_id); end

  # Determines if the model supports JSON mode
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports JSON mode
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#85
  def supports_json_mode?(model_id); end

  # Determines if the model supports tuning
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports tuning
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#122
  def supports_tuning?(model_id); end

  # Determines if the model supports vision (image/video) inputs
  #
  # @param model_id [String] the model identifier
  # @return [Boolean] true if the model supports vision inputs
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#67
  def supports_vision?(model_id); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#286
    def capabilities_for(model_id); end

    # Returns the context length for the model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the context length in tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#193
    def context_length(model_id); end

    # Returns the context window size (input token limit) for the given model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the context window size in tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#13
    def context_window_for(model_id); end

    # Default input price for unknown models
    #
    # @return [Float] the default input price per million tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#255
    def default_input_price; end

    # Default output price for unknown models
    #
    # @return [Float] the default output price per million tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#261
    def default_output_price; end

    # Formats the model ID into a human-readable display name
    #
    # @param model_id [String] the model identifier
    # @return [String] the formatted display name
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#96
    def format_display_name(model_id); end

    # Returns the input price per million tokens for the given model
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens in USD
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#45
    def input_price_for(model_id); end

    # Determines if the model supports long context
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports long context
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#186
    def long_context_model?(model_id); end

    # Returns the maximum output tokens for the given model
    #
    # @param model_id [String] the model identifier
    # @return [Integer] the maximum output tokens
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#29
    def max_tokens_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#265
    def modalities_for(model_id); end

    # Returns the model family identifier
    #
    # @param model_id [String] the model identifier
    # @return [String] the model family identifier
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#147
    def model_family(model_id); end

    # Returns the type of model (chat, embedding, image)
    #
    # @param model_id [String] the model identifier
    # @return [String] the model type
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#136
    def model_type(model_id); end

    # Returns the output price per million tokens for the given model
    #
    # @param model_id [String] the model identifier
    # @return [Float] the price per million tokens in USD
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#56
    def output_price_for(model_id); end

    # Returns the pricing family identifier for the model
    #
    # @param model_id [String] the model identifier
    # @return [Symbol] the pricing family identifier
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#167
    def pricing_family(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#307
    def pricing_for(model_id); end

    # Determines if the model supports audio inputs
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports audio inputs
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#129
    def supports_audio?(model_id); end

    # Determines if the model supports context caching
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports caching
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#111
    def supports_caching?(model_id); end

    # Determines if the model supports function calling
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports function calling
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#76
    def supports_functions?(model_id); end

    # Determines if the model supports JSON mode
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports JSON mode
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#85
    def supports_json_mode?(model_id); end

    # Determines if the model supports tuning
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports tuning
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#122
    def supports_tuning?(model_id); end

    # Determines if the model supports vision (image/video) inputs
    #
    # @param model_id [String] the model identifier
    # @return [Boolean] true if the model supports vision inputs
    #
    # source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#67
    def supports_vision?(model_id); end
  end
end

# Pricing information for Gemini models (per 1M tokens in USD)
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/capabilities.rb#198
RubyLLM::Providers::Gemini::Capabilities::PRICES = T.let(T.unsafe(nil), Hash)

# Chat methods for the Gemini API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#7
module RubyLLM::Providers::Gemini::Chat
  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#10
  def completion_url; end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#82
  def extract_content(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#28
  def format_messages(messages); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#45
  def format_parts(msg); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#37
  def format_role(role); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#97
  def function_call?(candidate); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#68
  def parse_completion_response(response); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#14
  def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#10
    def completion_url; end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/chat.rb#14
    def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end
  end
end

# Embeddings methods for the Gemini API integration
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#7
module RubyLLM::Providers::Gemini::Embeddings
  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#10
  def embedding_url(model:); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#18
  def parse_embedding_response(response, model:); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#14
  def render_embedding_payload(text, model:, dimensions:); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#27
  def single_embedding_payload(text, model:, dimensions:); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#10
    def embedding_url(model:); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#18
    def parse_embedding_response(response, model:); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/embeddings.rb#14
    def render_embedding_payload(text, model:, dimensions:); end
  end
end

# Image generation methods for the Gemini API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/images.rb#7
module RubyLLM::Providers::Gemini::Images
  # source://ruby_llm//lib/ruby_llm/providers/gemini/images.rb#8
  def images_url; end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/images.rb#27
  def parse_image_response(response, model:); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/images.rb#12
  def render_image_payload(prompt, model:, size:); end
end

# Media handling methods for the Gemini API integration
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#7
module RubyLLM::Providers::Gemini::Media
  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#30
  def format_attachment(attachment); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#10
  def format_content(content); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#45
  def format_text(text); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#39
  def format_text_file(text_file); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#30
    def format_attachment(attachment); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#10
    def format_content(content); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#45
    def format_text(text); end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/media.rb#39
    def format_text_file(text_file); end
  end
end

# Models methods for the Gemini API integration
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/models.rb#7
module RubyLLM::Providers::Gemini::Models
  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/models.rb#10
  def models_url; end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/models.rb#14
  def parse_list_models_response(response, slug, capabilities); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/gemini/models.rb#10
    def models_url; end

    # source://ruby_llm//lib/ruby_llm/providers/gemini/models.rb#14
    def parse_list_models_response(response, slug, capabilities); end
  end
end

# Streaming methods for the Gemini API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#7
module RubyLLM::Providers::Gemini::Streaming
  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#12
  def build_chunk(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#8
  def stream_url; end

  private

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#29
  def extract_content(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#40
  def extract_input_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#25
  def extract_model_id(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#44
  def extract_output_tokens(data); end

  # source://ruby_llm//lib/ruby_llm/providers/gemini/streaming.rb#48
  def parse_streaming_error(data); end
end

# Tools methods for the Gemini API implementation
#
# source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#7
module RubyLLM::Providers::Gemini::Tools
  # Extract tool calls from response data
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#18
  def extract_tool_calls(data); end

  # Format tools for Gemini API
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#9
  def format_tools(tools); end

  private

  # Format tool parameters for Gemini API
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#62
  def format_parameters(parameters); end

  # Format a single tool for Gemini API
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#53
  def function_declaration_for(tool); end

  # Convert RubyLLM param types to Gemini API types
  #
  # source://ruby_llm//lib/ruby_llm/providers/gemini/tools.rb#76
  def param_type_for_gemini(type); end
end

# Ollama API integration.
#
# source://ruby_llm//lib/ruby_llm/providers/ollama.rb#6
module RubyLLM::Providers::Ollama
  extend ::RubyLLM::Providers::OpenAI
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::OpenAI::Chat
  extend ::RubyLLM::Providers::OpenAI::Embeddings
  extend ::RubyLLM::Providers::OpenAI::Models
  extend ::RubyLLM::Providers::OpenAI::Streaming
  extend ::RubyLLM::Providers::OpenAI::Tools
  extend ::RubyLLM::Providers::OpenAI::Images
  extend ::RubyLLM::Providers::OpenAI::Media
  extend ::RubyLLM::Providers::Ollama::Chat
  extend ::RubyLLM::Providers::Ollama::Media

  private

  # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#13
  def api_base(config); end

  # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#25
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#17
  def headers(_config); end

  # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#29
  def local?; end

  # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#21
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#13
    def api_base(config); end

    # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#25
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#17
    def headers(_config); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#29
    def local?; end

    # source://ruby_llm//lib/ruby_llm/providers/ollama.rb#21
    def slug; end
  end
end

# Chat methods of the Ollama API integration
#
# source://ruby_llm//lib/ruby_llm/providers/ollama/chat.rb#7
module RubyLLM::Providers::Ollama::Chat
  private

  # source://ruby_llm//lib/ruby_llm/providers/ollama/chat.rb#10
  def format_messages(messages); end

  # source://ruby_llm//lib/ruby_llm/providers/ollama/chat.rb#21
  def format_role(role); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/ollama/chat.rb#10
    def format_messages(messages); end

    # source://ruby_llm//lib/ruby_llm/providers/ollama/chat.rb#21
    def format_role(role); end
  end
end

# Handles formatting of media content (images, audio) for OpenAI APIs
#
# source://ruby_llm//lib/ruby_llm/providers/ollama/media.rb#7
module RubyLLM::Providers::Ollama::Media
  extend ::RubyLLM::Providers::OpenAI::Media

  private

  # source://ruby_llm//lib/ruby_llm/providers/ollama/media.rb#12
  def format_content(content); end

  # source://ruby_llm//lib/ruby_llm/providers/ollama/media.rb#36
  def format_image(image); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/ollama/media.rb#12
    def format_content(content); end

    # source://ruby_llm//lib/ruby_llm/providers/ollama/media.rb#36
    def format_image(image); end
  end
end

# OpenAI API integration. Handles chat completion, function calling,
# and OpenAI's unique streaming format. Supports GPT-4, GPT-3.5,
# and other OpenAI models.
#
# source://ruby_llm//lib/ruby_llm/providers/openai.rb#8
module RubyLLM::Providers::OpenAI
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::OpenAI::Chat
  extend ::RubyLLM::Providers::OpenAI::Embeddings
  extend ::RubyLLM::Providers::OpenAI::Models
  extend ::RubyLLM::Providers::OpenAI::Streaming
  extend ::RubyLLM::Providers::OpenAI::Tools
  extend ::RubyLLM::Providers::OpenAI::Images
  extend ::RubyLLM::Providers::OpenAI::Media

  private

  # source://ruby_llm//lib/ruby_llm/providers/openai.rb#31
  def api_base(config); end

  # source://ruby_llm//lib/ruby_llm/providers/openai.rb#43
  def capabilities; end

  # source://ruby_llm//lib/ruby_llm/providers/openai.rb#51
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/openai.rb#35
  def headers(config); end

  # source://ruby_llm//lib/ruby_llm/providers/openai.rb#47
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#31
    def api_base(config); end

    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#43
    def capabilities; end

    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#51
    def configuration_requirements; end

    # @private
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#18
    def extended(base); end

    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#35
    def headers(config); end

    # source://ruby_llm//lib/ruby_llm/providers/openai.rb#47
    def slug; end
  end
end

# Determines capabilities and pricing for OpenAI models
#
# source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#7
module RubyLLM::Providers::OpenAI::Capabilities
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#196
  def apply_special_formatting(name); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#154
  def cached_input_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#254
  def capabilities_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#44
  def context_window_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#176
  def default_input_price; end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#180
  def default_output_price; end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#184
  def format_display_name(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#189
  def humanize(id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#148
  def input_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#60
  def max_tokens_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#227
  def modalities_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#141
  def model_family(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#166
  def model_type(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#218
  def normalize_temperature(temperature, model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#160
  def output_price_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#275
  def pricing_for(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#209
  def special_prefix_format(prefix); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#85
  def supports_functions?(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#103
  def supports_json_mode?(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#95
  def supports_structured_output?(model_id); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#77
  def supports_vision?(model_id); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#196
    def apply_special_formatting(name); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#154
    def cached_input_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#254
    def capabilities_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#44
    def context_window_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#176
    def default_input_price; end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#180
    def default_output_price; end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#184
    def format_display_name(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#189
    def humanize(id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#148
    def input_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#60
    def max_tokens_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#227
    def modalities_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#141
    def model_family(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#166
    def model_type(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#218
    def normalize_temperature(temperature, model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#160
    def output_price_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#275
    def pricing_for(model_id); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#209
    def special_prefix_format(prefix); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#85
    def supports_functions?(model_id); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#103
    def supports_json_mode?(model_id); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#95
    def supports_structured_output?(model_id); end

    # @return [Boolean]
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#77
    def supports_vision?(model_id); end
  end
end

# source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#10
RubyLLM::Providers::OpenAI::Capabilities::MODEL_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://ruby_llm//lib/ruby_llm/providers/openai/capabilities.rb#107
RubyLLM::Providers::OpenAI::Capabilities::PRICES = T.let(T.unsafe(nil), Hash)

# Chat methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#7
module RubyLLM::Providers::OpenAI::Chat
  # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#8
  def completion_url; end

  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#48
  def format_messages(messages); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#59
  def format_role(role); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#29
  def parse_completion_response(response); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#14
  def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#48
    def format_messages(messages); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#59
    def format_role(role); end

    # @raise [Error]
    #
    # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#29
    def parse_completion_response(response); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/chat.rb#14
    def render_payload(messages, tools:, temperature:, model:, stream: T.unsafe(nil)); end
  end
end

# Embeddings methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#7
module RubyLLM::Providers::OpenAI::Embeddings
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#10
  def embedding_url(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#22
  def parse_embedding_response(response, model:); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#14
  def render_embedding_payload(text, model:, dimensions:); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#10
    def embedding_url(*_arg0, **_arg1, &_arg2); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#22
    def parse_embedding_response(response, model:); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/embeddings.rb#14
    def render_embedding_payload(text, model:, dimensions:); end
  end
end

# Image generation methods for the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#7
module RubyLLM::Providers::OpenAI::Images
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#10
  def images_url; end

  # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#23
  def parse_image_response(response, model:); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#14
  def render_image_payload(prompt, model:, size:); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#10
    def images_url; end

    # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#23
    def parse_image_response(response, model:); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/images.rb#14
    def render_image_payload(prompt, model:, size:); end
  end
end

# Handles formatting of media content (images, audio) for OpenAI APIs
#
# source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#7
module RubyLLM::Providers::OpenAI::Media
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#60
  def format_audio(audio); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#10
  def format_content(content); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#34
  def format_image(image); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#43
  def format_pdf(pdf); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#70
  def format_text(text); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#53
  def format_text_file(text_file); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#60
    def format_audio(audio); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#10
    def format_content(content); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#34
    def format_image(image); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#43
    def format_pdf(pdf); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#70
    def format_text(text); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/media.rb#53
    def format_text_file(text_file); end
  end
end

# Models methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/models.rb#7
module RubyLLM::Providers::OpenAI::Models
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/models.rb#10
  def models_url; end

  # source://ruby_llm//lib/ruby_llm/providers/openai/models.rb#14
  def parse_list_models_response(response, slug, capabilities); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/models.rb#10
    def models_url; end

    # source://ruby_llm//lib/ruby_llm/providers/openai/models.rb#14
    def parse_list_models_response(response, slug, capabilities); end
  end
end

# Streaming methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/streaming.rb#7
module RubyLLM::Providers::OpenAI::Streaming
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/streaming.rb#14
  def build_chunk(data); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/streaming.rb#10
  def stream_url; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/streaming.rb#14
    def build_chunk(data); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/streaming.rb#10
    def stream_url; end
  end
end

# Tools methods of the OpenAI API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#7
module RubyLLM::Providers::OpenAI::Tools
  private

  # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#32
  def format_tool_calls(tool_calls); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#25
  def param_schema(param); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#47
  def parse_tool_calls(tool_calls, parse_arguments: T.unsafe(nil)); end

  # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#10
  def tool_for(tool); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#32
    def format_tool_calls(tool_calls); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#25
    def param_schema(param); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#47
    def parse_tool_calls(tool_calls, parse_arguments: T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/providers/openai/tools.rb#10
    def tool_for(tool); end
  end
end

# OpenRouter API integration.
#
# source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#6
module RubyLLM::Providers::OpenRouter
  extend ::RubyLLM::Providers::OpenAI
  extend ::RubyLLM::Provider
  extend ::RubyLLM::Provider::Methods
  extend ::RubyLLM::Streaming
  extend ::RubyLLM::Providers::OpenAI::Chat
  extend ::RubyLLM::Providers::OpenAI::Embeddings
  extend ::RubyLLM::Providers::OpenAI::Models
  extend ::RubyLLM::Providers::OpenAI::Streaming
  extend ::RubyLLM::Providers::OpenAI::Tools
  extend ::RubyLLM::Providers::OpenAI::Images
  extend ::RubyLLM::Providers::OpenAI::Media
  extend ::RubyLLM::Providers::OpenRouter::Models

  private

  # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#12
  def api_base(_config); end

  # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#26
  def configuration_requirements; end

  # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#16
  def headers(config); end

  # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#22
  def slug; end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#12
    def api_base(_config); end

    # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#26
    def configuration_requirements; end

    # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#16
    def headers(config); end

    # source://ruby_llm//lib/ruby_llm/providers/openrouter.rb#22
    def slug; end
  end
end

# Models methods of the OpenRouter API integration
#
# source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#7
module RubyLLM::Providers::OpenRouter::Models
  private

  # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#10
  def models_url; end

  # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#14
  def parse_list_models_response(response, slug, _capabilities); end

  # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#62
  def supported_parameters_to_capabilities(params); end

  class << self
    # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#10
    def models_url; end

    # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#14
    def parse_list_models_response(response, slug, _capabilities); end

    # source://ruby_llm//lib/ruby_llm/providers/openrouter/models.rb#62
    def supported_parameters_to_capabilities(params); end
  end
end

# Rails integration for RubyLLM
#
# source://ruby_llm//lib/ruby_llm/railtie.rb#5
class RubyLLM::Railtie < ::Rails::Railtie; end

# source://ruby_llm//lib/ruby_llm/error.rb#34
class RubyLLM::RateLimitError < ::RubyLLM::Error; end

# source://ruby_llm//lib/ruby_llm/error.rb#35
class RubyLLM::ServerError < ::RubyLLM::Error; end

# source://ruby_llm//lib/ruby_llm/error.rb#36
class RubyLLM::ServiceUnavailableError < ::RubyLLM::Error; end

# Assembles streaming responses from LLMs into complete messages.
# Handles the complexities of accumulating content and tool calls
# from partial chunks while tracking token usage.
#
# source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#7
class RubyLLM::StreamAccumulator
  # @return [StreamAccumulator] a new instance of StreamAccumulator
  #
  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#10
  def initialize; end

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#18
  def add(chunk); end

  # Returns the value of attribute content.
  #
  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#8
  def content; end

  # Returns the value of attribute model_id.
  #
  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#8
  def model_id; end

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#32
  def to_message; end

  # Returns the value of attribute tool_calls.
  #
  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#8
  def tool_calls; end

  private

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#63
  def accumulate_tool_calls(new_tool_calls); end

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#91
  def count_tokens(chunk); end

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#82
  def find_tool_call(tool_call_id); end

  # source://ruby_llm//lib/ruby_llm/stream_accumulator.rb#45
  def tool_calls_from_stream; end
end

# Handles streaming responses from AI providers. Provides a unified way to process
# chunked responses, accumulate content, and handle provider-specific streaming formats.
# Each provider implements provider-specific parsing while sharing common stream handling
# patterns.
#
# source://ruby_llm//lib/ruby_llm/streaming.rb#8
module RubyLLM::Streaming
  private

  # source://ruby_llm//lib/ruby_llm/streaming.rb#48
  def create_stream_processor(parser, buffer, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#84
  def error_chunk?(chunk); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#117
  def handle_data(data); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#88
  def handle_error_chunk(chunk, env); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#123
  def handle_error_event(data, env); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#97
  def handle_failed_response(chunk, buffer, env); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#106
  def handle_sse(chunk, parser, env, &block); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#33
  def handle_stream(&block); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#68
  def legacy_stream_processor(parser, &block); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#58
  def process_stream_chunk(chunk, parser, _env, &_arg3); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#74
  def stream_processor(parser, buffer, &block); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#11
  def stream_response(connection, payload, &block); end

  # source://ruby_llm//lib/ruby_llm/streaming.rb#41
  def to_json_stream(&_arg0); end

  class << self
    # source://ruby_llm//lib/ruby_llm/streaming.rb#33
    def handle_stream(&block); end

    # source://ruby_llm//lib/ruby_llm/streaming.rb#11
    def stream_response(connection, payload, &block); end
  end
end

# Base class for creating tools that AI models can use. Provides a simple
# interface for defining parameters and implementing tool behavior.
#
# Example:
#    require 'tzinfo'
#
#    class TimeInfo < RubyLLM::Tool
#      description 'Gets the current time in various timezones'
#      param :timezone, desc: "Timezone name (e.g., 'UTC', 'America/New_York')"
#
#      def execute(timezone:)
#        time = TZInfo::Timezone.get(timezone).now.strftime('%Y-%m-%d %H:%M:%S')
#        "Current time in #{timezone}: #{time}"
#       rescue StandardError => e
#          { error: e.message }
#       end
#    end
#
# source://ruby_llm//lib/ruby_llm/tool.rb#34
class RubyLLM::Tool
  # source://ruby_llm//lib/ruby_llm/tool.rb#70
  def call(args); end

  # source://ruby_llm//lib/ruby_llm/tool.rb#62
  def description; end

  # @raise [NotImplementedError]
  #
  # source://ruby_llm//lib/ruby_llm/tool.rb#77
  def execute(*_arg0, **_arg1, &_arg2); end

  # source://ruby_llm//lib/ruby_llm/tool.rb#51
  def name; end

  # source://ruby_llm//lib/ruby_llm/tool.rb#66
  def parameters; end

  class << self
    # source://ruby_llm//lib/ruby_llm/tool.rb#36
    def description(text = T.unsafe(nil)); end

    # source://ruby_llm//lib/ruby_llm/tool.rb#42
    def param(name, **options); end

    # source://ruby_llm//lib/ruby_llm/tool.rb#46
    def parameters; end
  end
end

# Represents a function call from an AI model to a Tool.
# Encapsulates the function name, arguments, and execution results
# in a clean Ruby interface.
#
# Example:
#   tool_call = ToolCall.new(
#     id: "call_123",
#     name: "calculator",
#     arguments: { expression: "2 + 2" }
#   )
#
# source://ruby_llm//lib/ruby_llm/tool_call.rb#14
class RubyLLM::ToolCall
  # @return [ToolCall] a new instance of ToolCall
  #
  # source://ruby_llm//lib/ruby_llm/tool_call.rb#17
  def initialize(id:, name:, arguments: T.unsafe(nil)); end

  # Returns the value of attribute arguments.
  #
  # source://ruby_llm//lib/ruby_llm/tool_call.rb#15
  def arguments; end

  # Returns the value of attribute id.
  #
  # source://ruby_llm//lib/ruby_llm/tool_call.rb#15
  def id; end

  # Returns the value of attribute name.
  #
  # source://ruby_llm//lib/ruby_llm/tool_call.rb#15
  def name; end

  # source://ruby_llm//lib/ruby_llm/tool_call.rb#23
  def to_h; end
end

# source://ruby_llm//lib/ruby_llm/error.rb#37
class RubyLLM::UnauthorizedError < ::RubyLLM::Error; end

# source://ruby_llm//lib/ruby_llm/error.rb#27
class RubyLLM::UnsupportedAttachmentError < ::StandardError; end

# source://ruby_llm//lib/ruby_llm/error.rb#26
class RubyLLM::UnsupportedFunctionsError < ::StandardError; end

# Provides utility functions for data manipulation within the RubyLLM library
#
# source://ruby_llm//lib/ruby_llm/utils.rb#5
module RubyLLM::Utils
  private

  # source://ruby_llm//lib/ruby_llm/utils.rb#8
  def format_text_file_for_llm(text_file); end

  # source://ruby_llm//lib/ruby_llm/utils.rb#12
  def hash_get(hash, key); end

  # source://ruby_llm//lib/ruby_llm/utils.rb#16
  def to_safe_array(item); end

  class << self
    # source://ruby_llm//lib/ruby_llm/utils.rb#8
    def format_text_file_for_llm(text_file); end

    # source://ruby_llm//lib/ruby_llm/utils.rb#12
    def hash_get(hash, key); end

    # source://ruby_llm//lib/ruby_llm/utils.rb#16
    def to_safe_array(item); end
  end
end

# source://ruby_llm//lib/ruby_llm/version.rb#4
RubyLLM::VERSION = T.let(T.unsafe(nil), String)
